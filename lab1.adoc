:author: Залипаева Эвелина КЭ-201
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
= Основные этапы разработки ПО

== Сбор и анализ требований

* На этом этапе аналитики и бизнес-архитекторы работают с заказчиком, чтобы понять, что именно нужно реализовать.
* Определяются цели, функциональные и нефункциональные требования.
* Это требует глубокого понимания бизнес-процессов и умения коммуницировать с заинтересованными сторонами.

== Проектирование (дизайн)

* Архитекторы и senior-разработчики создают высокоуровневую архитектуру системы.
* Определяются технологии, фреймворки, базы данных, API и другие компоненты.
* Проектирование требует большого опыта и понимания, как разные части системы будут взаимодействовать.

== Разработка (кодирование)

* На этом этапе пишется код. Этим обычно занимаются разработчики, включая junior и middle-инженеров.
* Код должен соответствовать требованиям и стандартам, определённым на этапе проектирования.
* Это самый трудоёмкий этап, но он часто требует меньше опыта, чем проектирование или анализ.

== Тестирование

* QA-инженеры проверяют, соответствует ли ПО требованиям и работает ли оно без ошибок.
* Тестирование может быть ручным или автоматизированным.
* Это требует внимательности и понимания процессов тестирования.

== Внедрение

* Система разворачивается на серверах или в облаке.
* Этим занимаются DevOps-инженеры, которые настраивают инфраструктуру и обеспечивают стабильную работу системы.

== Сопровождение и поддержка

* После запуска система требует обновлений, исправления багов и доработок.
* Этим могут заниматься как разработчики, так и отдельные команды поддержки.

= Почему код пишут самые низкоквалифицированные инженеры?

== Трудоёмкость и рутинность

* Написание кода — это часто рутинная задача, особенно если архитектура и требования уже определены. Это позволяет поручить её менее опытным разработчикам, которые могут следовать готовым инструкциям.

== Обучение и рост

* Junior-разработчики начинают с написания кода, чтобы набраться опыта. Это их первый шаг в карьере, и они учатся на реальных задачах.

== Экономическая эффективность

* Опытные разработчики и архитекторы стоят дороже. Их время лучше использовать для решения сложных задач, таких как проектирование системы или оптимизация, а не для написания базового кода.

== Разделение труда

* В крупных проектах задачи разделяются между членами команды. Более опытные специалисты занимаются архитектурой, код-ревью и решением сложных проблем, а junior-разработчики пишут код под их руководством.

== Автоматизация и стандартизация

* Современные инструменты разработки (например, фреймворки, библиотеки, шаблоны) позволяют писать код с минимальными ошибками даже начинающим разработчикам. Это снижает риски и упрощает процесс.

= Процесс компиляции

== Основные этапы компиляции

=== Лексический анализ (Lexical Analysis)

* **Цель:** Разбить исходный код на токены (лексемы).
* **Процесс:**
  * Компилятор читает исходный код как последовательность символов.
  * Группирует символы в токены (например, ключевые слова, идентификаторы, операторы, числа, строки).
  * Удаляет пробелы, комментарии и другие незначимые элементы.

=== Синтаксический анализ (Parsing)

* **Цель:** Проверить, соответствует ли последовательность токенов правилам языка (грамматике).
* **Процесс:**
  * Компилятор строит синтаксическое дерево (Abstract Syntax Tree, AST), которое отражает структуру программы.
  * Если код не соответствует грамматике, компилятор выдаёт ошибку.

=== Семантический анализ (Semantic Analysis)

* **Цель:** Проверить смысловую корректность программы.
* **Процесс:**
  * Компилятор проверяет типы данных, области видимости переменных, вызовы функций и другие аспекты.
  * Добавляет информацию в AST (например, типы переменных).

=== Промежуточное представление (Intermediate Representation, IR)

* **Цель:** Преобразовать AST в промежуточный код, который легче оптимизировать.
* **Процесс:**
  * Компилятор генерирует промежуточный код (например, трёхадресный код или LLVM IR). Этот код не зависит от архитектуры процессора.

=== Оптимизация

* **Цель:** Улучшить производительность и эффективность кода.
* **Процесс:**
  * Компилятор применяет различные оптимизации (удаление мёртвого кода, разворачивание циклов, инлайнинг функций и т.д.).
  * Оптимизации выполняются на промежуточном коде.

=== Генерация кода

* **Цель:** Преобразовать промежуточный код в машинный код (или объектный код).
* **Процесс:**
  * Компилятор генерирует инструкции для целевой архитектуры процессора.
  * Код может быть в виде ассемблера или бинарного формата.

=== Сборка

* **Цель:** Собрать все объектные файлы и библиотеки в один исполняемый файл.
* **Процесс:**
  * Линкер объединяет объектные файлы, разрешает ссылки на внешние функции и библиотеки.
  * Создаёт исполняемый файл (например, .exe для Windows или ELF для Linux).

= Как запускается функция main(), какие этапы и что делает контроллер до вызова функции main

== Этапы до вызова функции main()

=== Загрузка программы в память

* Когда вы запускаете программу, операционная система (ОС) загружает её исполняемый файл (например, .exe или ELF) в память.
* ОС выделяет адресное пространство для программы, загружает секции кода, данных и других ресурсов.

=== Инициализация runtime-окружения

* Перед вызовом main() runtime-библиотека (например, crt0 в C/C++) выполняет начальную настройку:
  * Инициализирует глобальные и статические переменные.
  * Настраивает стек и кучу (heap).
  * Подготавливает окружение для работы программы (например, аргументы командной строки, переменные окружения).

=== Инициализация стандартной библиотеки

* Если программа использует стандартную библиотеку (например, libc в C или libstdc++ в C++), runtime-система инициализирует её:
  * Настраивает потоки ввода-вывода (stdin, stdout, stderr).
  * Инициализирует глобальные объекты (в C++ вызываются конструкторы глобальных объектов).

=== Передача аргументов в main()

* Runtime-система подготавливает аргументы командной строки (argc, argv) и передаёт их в функцию main().

=== Вызов main()

* После завершения всех подготовительных этапов управление передаётся в функцию main(), которая является точкой входа в программу.

== Что происходит внутри функции main()

* Внутри main() программа начинает выполнять код, написанный разработчиком.
* После завершения main() управление возвращается в runtime-систему.

=== Что происходит после завершения main()

==== Завершение работы программы

* Если main() возвращает управление, runtime-система выполняет финальные действия:
  * Вызывает деструкторы глобальных объектов (в C++).
  * Закрывает открытые файлы и освобождает ресурсы.
  * Возвращает код завершения операционной системе.

==== Завершение работы runtime-окружения

* Runtime-система завершает свою работу и передаёт управление обратно ОС.

= Почему в коде получается 12, а не 13

== Статическая переменная внутри функции

* Статическая переменная (static int result) инициализируется только один раз — при первом вызове функции.
* После инициализации она сохраняет своё значение между вызовами функции.
* Её время жизни — до завершения программы.

== Первый вызов Increment(10)

* Статическая переменная result инициализируется значением 10.
* Затем она увеличивается на 1 (result++), и её значение становится 11.
* Функция возвращает 11.

== Второй вызов Increment(12)

* Статическая переменная result не инициализируется заново, так как она уже была инициализирована при первом вызове.
* Её текущее значение (11) увеличивается на 1 (result++), и она становится равной 12.
* Функция возвращает 12.

== Почему не 13?

* Второй вызов Increment(12) не использует переданное значение 12 для инициализации статической переменной, так как она уже была инициализирована при первом вызове.
* Вместо этого статическая переменная просто увеличивается на 1 от своего предыдущего значения (11), что даёт 12.
