:author: Залипаева Эвелина КЭ-201
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
= Основные этапы разработки ПО

----
@startuml
title Основные этапы разработки ПО

start
:Сбор и анализ требований;
:Проектирование (дизайн);
:Разработка (кодирование);
:Тестирование;
:Внедрение;
:Сопровождение и поддержка;
stop
@enduml
----
== Сбор и анализ требований

* На этом этапе аналитики и бизнес-архитекторы работают с заказчиком, чтобы понять, что именно нужно реализовать.
* Определяются цели, функциональные и нефункциональные требования.
* Это требует глубокого понимания бизнес-процессов и умения коммуницировать с заинтересованными сторонами.

== Проектирование (дизайн)

* Архитекторы и senior-разработчики создают высокоуровневую архитектуру системы.
* Определяются технологии, фреймворки, базы данных, API и другие компоненты.
* Проектирование требует большого опыта и понимания, как разные части системы будут взаимодействовать.
== Разработка (кодирование)
* На этом этапе пишется код. Этим обычно занимаются разработчики, включая junior и middle-инженеров.
* Код должен соответствовать требованиям и стандартам, определённым на этапе проектирования.
* Это самый трудоёмкий этап, но он часто требует меньше опыта, чем проектирование или анализ.

== Тестирование
* Тестирование может быть ручным или автоматизированным.
* Это требует внимательности и понимания процессов тестирования.

== Внедрение
* Этим занимаются DevOps-инженеры, которые настраивают инфраструктуру и обеспечивают стабильную работу системы.

== Сопровождение и поддержка

* После запуска система требует обновлений, исправления багов и доработок.
* Этим могут заниматься как разработчики, так и отдельные команды поддержки.

== Почему код пишут самые низкоквалифицированные инженеры?

=== Трудоёмкость и рутинность

* Написание кода — это часто рутинная задача, особенно если архитектура и требования уже определены. Это позволяет поручить её менее опытным разработчикам, которые могут следовать готовым инструкциям.

=== Обучение и рост

* Junior-разработчики начинают с написания кода, чтобы набраться опыта. Это их первый шаг в карьере, и они учатся на реальных задачах.

=== Экономическая эффективность

* Опытные разработчики и архитекторы стоят дороже. Их время лучше использовать для решения сложных задач, таких как проектирование системы или оптимизация, а не для написания базового кода.

=== Разделение труда

* В крупных проектах задачи разделяются между членами команды. Более опытные специалисты занимаются архитектурой, код-ревью и решением сложных проблем, а junior-разработчики пишут код под их руководством.

=== Автоматизация и стандартизация

* Современные инструменты разработки (например, фреймворки, библиотеки, шаблоны) позволяют писать код с минимальными ошибками даже начинающим разработчикам. Это снижает риски и упрощает процесс.

== Процесс компиляции (Основные этапы компиляции)


[plantuml, процесс-компиляции, png]
----
@startuml
title Основные этапы компиляции

start
:Синтаксический анализ (Parsing);
:Лексический анализ (Lexical Analysis);
:Семантический анализ (Semantic Analysis);
:Промежуточное представление (Intermediate Representation);
:Оптимизация;
:Генерация кода;
:Сборка (Linking);
stop

@enduml
----
=== Синтаксический анализ (Parsing)

* **Цель:** Проверить, соответствует ли последовательность токенов правилам языка (грамматике).
* **Процесс:**
  * Компилятор строит синтаксическое дерево (Abstract Syntax Tree, AST), которое отражает структуру программы.
  * Если код не соответствует грамматике, компилятор выдаёт ошибку.

=== Лексический анализ (Lexical Analysis)

* **Цель:** Разбить исходный код на токены (лексемы).
* **Процесс:**
  * Компилятор читает исходный код как последовательность символов.
  * Группирует символы в токены (например, ключевые слова, идентификаторы, операторы, числа, строки).
  * Удаляет пробелы, комментарии и другие незначимые элементы.


=== Семантический анализ (Semantic Analysis)

* **Цель:** Проверить смысловую корректность программы.
* **Процесс:**
  * Компилятор проверяет типы данных, области видимости переменных, вызовы функций и другие аспекты.
  * Добавляет информацию в AST (например, типы переменных).

=== Промежуточное представление (Intermediate Representation, IR)

* **Цель:** Преобразовать AST в промежуточный код, который легче оптимизировать.
* **Процесс:**
  * Компилятор генерирует промежуточный код (например, трёхадресный код или LLVM IR). Этот код не зависит от архитектуры процессора.

=== Оптимизация

* **Цель:** Улучшить производительность и эффективность кода.
* **Процесс:**
  * Компилятор применяет различные оптимизации (удаление мёртвого кода, разворачивание циклов, инлайнинг функций и т.д.).
  * Оптимизации выполняются на промежуточном коде.

=== Генерация кода

* **Цель:** Преобразовать промежуточный код в машинный код (или объектный код).
* **Процесс:**
  * Компилятор генерирует инструкции для целевой архитектуры процессора.
  * Код может быть в виде ассемблера или бинарного формата.

=== Сборка

* **Цель:** Собрать все объектные файлы и библиотеки в один исполняемый файл.
* **Процесс:**
  * Линкер объединяет объектные файлы, разрешает ссылки на внешние функции и библиотеки.
  * Создаёт исполняемый файл (например, .exe для Windows или ELF для Linux).

== Как запускается функция main(), какие этапы и что делает контроллер до вызова функции main


=== Основные этапы до вызова main()

На микроконтроллере STM32 (и других ARM Cortex-M) перед вызовом функции `main()` выполняется ряд важных этапов, которые обеспечивают подготовку аппаратной и программной среды. Эти этапы включают:

====  Сброс и запуск процессора
* При подаче питания или сбросе микроконтроллер начинает выполнение программы с адреса, указанного в векторе сброса (Reset Handler).
* Вектор сброса находится в начале таблицы векторов прерываний (обычно по адресу `0x00000000`).

====  Инициализация стека
* Первое значение в таблице векторов — это начальное значение указателя стека (SP). Оно загружается в регистр SP.
* Стек необходим для работы функций и обработки прерываний.

====  Вызов Reset Handler
* Второе значение в таблице векторов — адрес функции `Reset_Handler`. Это точка входа в программу после сброса.
* `Reset_Handler` — это ассемблерная функция, которая выполняет начальную настройку.

====  Копирование данных из Flash в RAM
* В `Reset_Handler` выполняется копирование секции `.data` (инициализированные глобальные и статические переменные) из Flash в RAM.
* Секция `.bss` (неинициализированные глобальные и статические переменные) заполняется нулями.

====  Настройка системы тактирования
* На этом этапе настраиваются источники тактирования (например, внутренний или внешний генератор, PLL).
* Это важно для правильной работы периферии и процессора.

====  Инициализация C-окружения
* Вызывается функция `__main()` (или `_start()`), которая является частью runtime-библиотеки (например, от компилятора ARM GCC или Keil).
* Эта функция выполняет дополнительные настройки, такие как вызов конструкторов глобальных объектов в C++.

====  Вызов main()
* После завершения всех подготовительных этапов управление передаётся в функцию `main()`, которая является точкой входа в пользовательскую программу.

=== Схема процесса

[plantuml, запуск-main, png]
----
@startuml
title Запуск функции main() на STM32

start
:Сброс и запуск процессора;
:Инициализация стека (SP);
:Вызов Reset Handler;
:Копирование .data из Flash в RAM;
:Инициализация .bss (заполнение нулями);
:Настройка системы тактирования;
:Инициализация C-окружения (__main);
:Вызов функции main();
stop

@enduml
----

=== Пример кода Reset Handler

Пример ассемблерного кода для `Reset_Handler`:

[source,asm]
----
Reset_Handler:
    // Инициализация стека
    ldr sp, =_estack

    // Копирование .data из Flash в RAM
    ldr r0, =_sdata
    ldr r1, =_edata
    ldr r2, =_sidata
    bl  memcpy

    // Инициализация .bss (заполнение нулями)
    ldr r0, =_sbss
    ldr r1, =_ebss
    bl  memset

    // Настройка системы тактирования
    bl  SystemInit

    // Инициализация C-окружения
    bl  __main

    // Вызов main()
    bl  main
----

=== Итог

До вызова `main()` на STM32 выполняется ряд важных этапов, которые обеспечивают корректную работу программы. Эти этапы включают инициализацию стека, копирование данных, настройку тактирования и инициализацию C-окружения. Схема, приведённая выше, наглядно демонстрирует этот процесс.