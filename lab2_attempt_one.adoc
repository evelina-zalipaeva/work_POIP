:author: Залипаева Эвелина КЭ-201
:icon: front
:secttrue: true
:toc: left
:toclevels: 2
:secttruelevels: 2
:sectnums: |,all|
:stylesheet: custom.css
:stylesdir: ./styles
:imagesdir: pic
:toc:
:toc-title: Оглавление
:figure-caption: Рисунок
:table-caption: Таблица
= Отчёт
== Типы данных

* **Базовые типы**: `int`, `float`, `double`, `char`, `bool`.
* **Составные типы**: массивы, структуры, указатели.
* **Размер типа**: вычисляется с помощью оператора `sizeof`. Например:
+
[source,cpp]
----
sizeof(int); // Возвращает размер типа int в байтах.
----

== Преобразование типов

* **Неявное преобразование**: автоматическое преобразование типов компилятором (например, `int` в `float`).
* **Явное преобразование**: принудительное преобразование с использованием операторов приведения:
  * `static_cast`: для безопасных преобразований (например, `int` в `float`).
  * `reinterpret_cast`: для низкоуровневых преобразований (например, указатель в `int`).
* **Проблемы преобразования типов**:
  * Потеря данных (например, при преобразовании `float` в `int`).
  * Неопределённое поведение.

== Указатели

* **Указатель** — переменная, хранящая адрес памяти.
* **Операции с указателями**:
  * `*` — разыменование.
  * `&` — получение адреса.
  * Арифметика указателей (`+`, `-`).
* **Почему нельзя вычитать указатели на разные объекты**:
  * Результат будет неопределённым, так как указатели могут находиться в разных областях памяти.

== Работа с битами

* **Установка бита**:
+
[source,cpp]
----
x |= (1 << n); // Установить n-й бит.
----

* **Сброс бита**:
+
[source,cpp]
----
x &= ~(1 << n); // Сбросить n-й бит.
----

* **Переключение бита**:
+
[source,cpp]
----
x ^= (1 << n); // Переключить n-й бит.
----

== Унарные операции `+` и `-`

* **Унарный `+`**:
  * Возвращает значение операнда без изменений.
  * Пример:
+
[source,cpp]
----
int x = +5; // x = 5
----

* **Унарный `-`**:
  * Меняет знак операнда на противоположный.
  * Пример:
+
[source,cpp]
----
int x = -5; // x = -5
----

== Проблема с `float` и большими числами

* В типах с плавающей точкой (`float`) мантисса имеет ограниченную точность (обычно 23 бита).
* При больших значениях (например, 17 000 000) единица может быть меньше наименьшего представимого числа (эпсилон), поэтому результат не изменится:
+
[source,cpp]
----
float x = 17000000.0f;
x = x + 1.0f; // x останется 17000000.0f
----

== Итог

* Типы данных и их размеры важны для понимания работы программы.
* Преобразование типов может быть неявным или явным, но требует осторожности.
* Указатели позволяют работать с памятью, но их использование требует внимания.
* Работа с битами — мощный инструмент для низкоуровневых операций.
* Унарные операции `+` и `-` просты, но полезны.
* Типы с плавающей точкой имеют ограниченную точность, что может привести к неожиданным результатам.

== Почему 7 != 7?

1. *Точность чисел с плавающей точкой*::
   Числа с плавающей точкой (например, `7.0`) могут храниться с погрешностью (например, `7.0000001`), что приводит к неравенству при сравнении.

2. *Проблемы с загрузкой данных*::
   Если в памяти (например, в `.rodata`) хранится не точно `7.0`, а близкое значение, сравнение `ucomiss` покажет неравенство.

3. *Ошибки в коде*::
   Нулевые значения (`0x0`) в инструкциях `mov esi, 0x0` и `mov edi, 0x0` могут указывать на некорректные данные.

== Решение:
- Проверьте значения в памяти.
- Используйте отладчик для анализа.
- Убедитесь, что все данные загружаются корректно.